{
  "title": "Calls and Returns",
  "updated_on": null,
  "summary": null,
  "categories": ["ethereum","functions"],
  "url": "/pages/example.html",
  "next": null,
  "previous": null,
  "content": "# Calls and Returns\n\n## Calls\n\nDuring the previous exercises, you‚Äôve been presented with mutability and visibility of function, but you have never used one. Function are useful to structure your code. In a spaceship, functions would be like buttons. Each one has its own behaviour, you can dive into it or just press it.\n\nAnd it looks like you haven‚Äôt been able to press any! Instead of *pressing* a function, you *call* it. It looks like the following\n```solidity\nuint public fans = 0;\n\nfunction increment() public pure returns (uint) {\n  return 2;\n}\n\nfunction like() public {\n  // `increment()` is the function call\n  // It will execute increment code and insert its return value in the expression\n  fans = fans + increment();\n}\n```\n\n{% exercise %}\nIt looks like `SpaceMuffin` had a secret recipe. Expose it to the world!\n{% initial %}\npragma solidity ^0.4.24;\n\ncontract SpaceMuffin {\n  // Secret recipe is here but inaccessible externally\n  function superSecretRecipe () private pure returns (string) {\n    return ‚ÄúIngredients: 1L SpaceMilk, 100g SpaceButter and 100g SpaceChocolate. Instructions: Mix, then bake 45min in your SpaceOven‚Äù;\n  }\n  \n  function contactMe () external pure returns (string) {\n    // As a malicious attacker, you want to expose the recipe\n    return ;\n  }\n}\n{% solution %}\npragma solidity ^0.4.24;\n\ncontract SpaceMuffin {\n  function superSecretRecipe () private pure returns (string) {\n    // Add some SpaceVanillaSugar to make them taste better\n    return ‚ÄúIngredients: 1L SpaceMilk, 100g SpaceButter and 100g SpaceChocolate. Instructions: Mix, then bake 45min in your SpaceOven‚Äù;\n  }\n  \n  function contactMe () external pure returns (string) {\n    // What a horrible person you are\n    // Exposing top secret information\n    return superSecretRecipe();\n  }\n}\n\n{% validation %}\npragma solidity ^0.4.24;\n\nimport ‚ÄúAssert.sol‚Äù;\nimport ‚ÄúSpaceMuffin.sol‚Äù;\n\ncontract TestSpaceMuffin {\n  SpaceMuffin spaceMuffin = SpaceMuffin(__ADDRESS__);\n  \n  function testContactMe() public {\n    string memory result = spaceMuffin.contactMe();\n    string memory expected = ‚ÄúIngredients: 1L SpaceMilk, 100g SpaceButter and 100g SpaceChocolate. Instructions: Mix, then bake 45min in your SpaceOven‚Äù;\n    Assert.equal(result, expected, ‚ÄúThe recipe you send is not the one expected‚Äù);\n  }\n  \n  event TestEvent(bool indexed result, string message);\n}\n\n{% endexercise %}\n\nCalling a function is like ringing a phone\n\n## Arguments\n\nDo you remember what a function signature looks like?\n```html\nfunction <name> ([arg1, arg2, ...]) <visibility> [mutability] [returns ([ret1, ret2, ...])] ;\n```\n\nAfter the function `name`, comes `([arg1, arg2, ...])`.\n\nIt allows you to pass fresh variables to your function.\n\n```solidity\nfunction like() public {\n  multiLike(1);\n}\n\nfunction multiLike(uint numberOfLikes) public {\n  fans = fans + numberOfLikes;\n}\n```\n\n{% exercise %}\nCryptadvisor has contacted you because they want to know if your muffin is recommended. You should create an `isRecommended` function that test if the muffin `isBestMuffin` and (`&amp;&amp;`) the number of `fans` is `notZero`\n{% initial %}\npragma solidity ^0.4.24;\n\ncontract SpaceMuffin {\n  uint public fans = 0;\n\n  // Now you know that this function is really simple\n  function like() public {\n    fans = fans + 1;\n  }\n\n  // welcome back, old friend\n  function isBestMuffin() public pure returns (bool) {\n    return true;\n  }\n  \n  // I've already made this function for you ;)\n  function notZero(uint number) internal pure returns (bool) {\n    return number != 0;\n  }\n  \n  // This function returns a boolean\n  function isRecommended() public view returns (bool) {\n    return ;\n  }\n}\n\n{% solution %}\npragma solidity ^0.4.24;\n\ncontract SpaceMuffin {\n  uint public fans = 0;\n\n  // I actually need it to check if your code is correct\n  function like() public {\n    fans = fans + 1;\n  }\n\n  // welcome back, old friend\n  // good recipe never dies\n  function isBestMuffin() public pure returns (bool) {\n    return true;\n  }\n  \n  // This function is actually not really necessary, it is just to practise :D\n  function notZero(uint number) internal pure returns (bool) {\n    return number != 0;\n  }\n  \n  // But what is a return ?\n  function isRecommended() public view returns (bool) {\n    return isBestMuffin() &amp;&amp; notZero(fans);\n  }\n}\n\n{% validation %}\npragma solidity ^0.4.24;\n\nimport \"Assert.sol\";\nimport \"SpaceMuffin.sol\";\n\ncontract TestSpaceMuffin {\n  SpaceMuffin spaceMuffin = SpaceMuffin(__ADDRESS__);\n  \n  function testNoFans() public {\n    bool result = spaceMuffin.isRecommended();\n    bool expect = false;\n    Assert.equal(result, expect, \"When there is no fans, space muffin is sadly not recommended\");\n  }\n  \n  function testWithFans() public {\n      spaceMuffin.like();\n      bool result = spaceMuffin.isRecommended();\n      bool expect = true;\n      Assert.equal(result, expect, \"There is at least one fan of the space muffin, it should be recommended\");\n    }\n    \n  event TestEvent(bool indexed result, string message);\n}\n\n{% endexercise %}\n\n## Return\n\n{% exercise %}\nThe Space Muffin contract is broken üò¢ You must make SpaceMuffin great again!\n\n{% initial %}\npragma solidity ^0.4.24;\n\ncontract SpaceMuffin {\n  uint public fans = 0;\n\n  // This function hasn't the proper return type\n  function isBestMuffin() public pure returns (uint) {\n    return true;\n  }\n  \n  // This one has, but has another problem\n  function getFans() public view returns (uint) {\n    return true;\n  }\n  \n  // You can name return variables :D\n  function superSecretRecipe() private pure returns (string recipe) {\n    recipe = \"Ingredients: 1L SpaceMilk, 100g SpaceButter and 100g SpaceChocolate. Instructions: Mix, then bake 45min in your SpaceOven\";\n  }\n}\n\n{% solution %}\n\npragma solidity ^0.4.24;\n\ncontract SpaceMuffin {\n  uint public fans = 0;\n\n  // This function hasn't the proper return type\n  function isBestMuffin() public pure returns (bool) {\n    return true;\n  }\n  \n  // This one has, but has another problem\n  function getFans() public view returns (uint) {\n    return fans;\n  }\n  \n  // As you might have notice, you don't even need a return\n  function superSecretRecipe() private pure returns (string recipe) {\n    recipe = \"Ingredients: 1L SpaceMilk, 100g SpaceButter and 100g SpaceChocolate. Instructions: Mix, then bake 45min in your SpaceOven\";\n  }\n}\n\n{% validation %}\npragma solidity ^0.4.24;\n\n// I don't want to put any validation here\n// It's more solving the compilation problem than executing test onchain\n\n{% endexercise %}\n\nOk, I haven't written anything but you should have got the point, haven't you?\nWhen called, functions do their internal little tricks and give you back results.\nThese results are associated with a type, so you can catch them within variables.\n\nIf a function `returns` something, there should be at least one `return` statement before it ends.\nIt acts as a promise. If I promise you a `SpaceMuffin`, I should give you one. ith the same process, if I give you a `SpaceSalad`, you won't be happy either.\n\n&gt; **Amiral tips**:\n&gt; Never give the compiler a `bool` when it expects a `uint`. `bool` are like `SpaceSalad`, you like them but not that much\n</visibility></name>"
}
